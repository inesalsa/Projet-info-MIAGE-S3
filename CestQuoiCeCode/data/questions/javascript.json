{
    "themes": [
        {
            "id": "js_basics",
            "name": "Bases & Coercition (Weird JS)",
            "questions": [
                {
                    "q": "Que vaut `[] + []` ?",
                    "code": "console.log([] + []);",
                    "opts": [
                        "[]",
                        "\"\"",
                        "0",
                        "undefined"
                    ],
                    "correct": 1,
                    "explanation": "En JS, l'opérateur `+` avec des tableaux déclenche une conversion en chaîne. `[].toString()` donne `\"\"`. Donc `\"\" + \"\"` = `\"\"`."
                },
                {
                    "q": "Que vaut `0.1 + 0.2 === 0.3` ?",
                    "code": "console.log(0.1 + 0.2 === 0.3);",
                    "opts": [
                        "true",
                        "false",
                        "undefined",
                        "NaN"
                    ],
                    "correct": 1,
                    "explanation": "C'est un problème classique des nombres flottants (IEEE 754). `0.1 + 0.2` vaut en réalité `0.30000000000000004`."
                },
                {
                    "q": "Quelle est la sortie ?",
                    "code": "console.log(typeof NaN);",
                    "opts": [
                        "\"number\"",
                        "\"NaN\"",
                        "\"undefined\"",
                        "\"object\""
                    ],
                    "correct": 0,
                    "explanation": "Ironiquement, `NaN` signifie 'Not a Number', mais son type est bien `\"number\"`."
                },
                {
                    "q": "Egalité stricte vs large",
                    "code": "console.log(5 == \"5\");\nconsole.log(5 === \"5\");",
                    "opts": [
                        "true, true",
                        "false, false",
                        "true, false",
                        "false, true"
                    ],
                    "correct": 2,
                    "explanation": "`==` fait une coercition de type (la chaîne \"5\" devient le nombre 5). `===` vérifie le type ET la valeur, sans conversion."
                },
                {
                    "q": "Que fait `'b' + 'a' + + 'a' + 'a'` ?",
                    "opts": [
                        "baaa",
                        "baNaNa",
                        "NaN",
                        "Error"
                    ],
                    "correct": 1,
                    "explanation": "Le `+ + 'a'` est interprété comme le signe unaire `+` appliqué à la chaîne `'a'`, ce qui donne `NaN`. Donc `'ba' + NaN + 'a'` = `\"baNaNa\"`."
                }
            ]
        },
        {
            "id": "es6",
            "name": "ES6+ Modern Syntax",
            "questions": [
                {
                    "q": "Que retourne cette fonction fléchée ?",
                    "code": "const f = () => ({ a: 1 });\nconsole.log(f());",
                    "opts": [
                        "undefined",
                        "{ a: 1 }",
                        "null",
                        "Erreur syntaxe"
                    ],
                    "correct": 1,
                    "explanation": "Pour retourner un objet littéral implicitement avec une arrow function, il faut l'entourer de parenthèses `({})`, sinon les accolades sont interprétées comme le bloc de la fonction."
                },
                {
                    "q": "Quel est le résultat de ce destructuring ?",
                    "code": "const {a, b=2} = {a: 10};\nconsole.log(a, b);",
                    "opts": [
                        "10 2",
                        "10 undefined",
                        "10 null",
                        "Erreur"
                    ],
                    "correct": 0,
                    "explanation": "`a` prend la valeur 10. `b` n'existe pas dans l'objet source, donc il prend sa valeur par défaut : 2."
                },
                {
                    "q": "Variables : var, let, const",
                    "code": "console.log(a);\nvar a = 5;",
                    "opts": [
                        "5",
                        "undefined",
                        "ReferenceError",
                        "null"
                    ],
                    "correct": 1,
                    "explanation": "C'est le 'Hoisting'. La déclaration `var a` est remontée en haut du scope, mais pas son initialisation. Donc `a` existe mais vaut `undefined`."
                }
            ]
        },
        {
            "id": "arrays",
            "name": "Tableaux & Méthodes",
            "questions": [
                {
                    "q": "Que retourne `map` ?",
                    "code": "const arr = [1, 2, 3];\nconst res = arr.map(x => x * 2);",
                    "opts": [
                        "Modifie arr directement",
                        "Retourne [2, 4, 6] (nouveau)",
                        "Retourne undefined",
                        "Erreur"
                    ],
                    "correct": 1,
                    "explanation": "`map` crée et retourne un NOUVEAU tableau. Le tableau original `arr` reste inchangé."
                },
                {
                    "q": "Que fait `reduce` ici ?",
                    "code": "[1, 2, 3, 4].reduce((acc, v) => acc + v, 0)",
                    "opts": [
                        "10",
                        "24",
                        "1",
                        "[1,2,3,4]"
                    ],
                    "correct": 0,
                    "explanation": "C'est la somme des éléments. 0 (valeur initiale) + 1 + 2 + 3 + 4 = 10."
                },
                {
                    "q": "Comment trier des nombres correctement ?",
                    "code": "[10, 2, 5].sort()",
                    "opts": [
                        "[2, 5, 10]",
                        "[10, 2, 5]",
                        "[10, 5, 2]",
                        "Dépend du navigateur"
                    ],
                    "correct": 1,
                    "explanation": "Par défaut, `sort()` convertit les éléments en chaînes de caractères. \"10\" arrive avant \"2\" (ordre alphabétique). Pour trier numériquement, il faut `.sort((a,b) => a - b)`."
                }
            ]
        },
        {
            "id": "async",
            "name": "Asynchrone & Event Loop",
            "questions": [
                {
                    "q": "Dans quel ordre ça s'affiche ?",
                    "code": "console.log(1);\nsetTimeout(() => console.log(2), 0);\nconsole.log(3);",
                    "opts": [
                        "1, 2, 3",
                        "1, 3, 2",
                        "3, 2, 1",
                        "Aléatoire"
                    ],
                    "correct": 1,
                    "explanation": "`setTimeout` (même avec 0ms) place la callback dans la 'Task Queue'. JS doit d'abord finir d'exécuter la stack actuelle (1, 3) avant de traiter la queue (2)."
                },
                {
                    "q": "Que retourne une fonction async ?",
                    "code": "async function f() {\n  return 1;\n}",
                    "opts": [
                        "1",
                        "Promise { 1 }",
                        "undefined",
                        "Function"
                    ],
                    "correct": 1,
                    "explanation": "Une fonction `async` enveloppe toujours sa valeur de retour dans une Promise résolue."
                },
                {
                    "q": "Microtasks vs Macrotasks",
                    "code": "setTimeout(() => console.log('Timeout'));\nPromise.resolve().then(() => console.log('Promise'));",
                    "opts": [
                        "Timeout, Promise",
                        "Promise, Timeout",
                        "Aléatoire",
                        "Erreur"
                    ],
                    "correct": 1,
                    "explanation": "Les Promises utilisent la file des 'Microtasks', qui a priorité sur la file des 'Macrotasks' (setTimeout). Donc la Promise s'exécute avant le Timeout."
                }
            ]
        },
        {
            "id": "dom",
            "name": "DOM & Events",
            "questions": [
                {
                    "q": "Comment sélectionner un élément par son ID ?",
                    "code": "<div id=\"app\"></div>",
                    "opts": [
                        "document.select('#app')",
                        "document.getElementById('app')",
                        "document.find('#app')",
                        "document.query('app')"
                    ],
                    "correct": 1,
                    "explanation": "`getElementById` est la méthode standard et rapide. `querySelector('#app')` fonctionne aussi."
                },
                {
                    "q": "Qu'est-ce que l'Event Bubbling ?",
                    "opts": [
                        "L'événement descend du parent vers l'enfant",
                        "L'événement remonte de l'enfant vers les parents",
                        "L'événement est annulé",
                        "L'événement se duplique"
                    ],
                    "correct": 1,
                    "explanation": "Par défaut, les événements (click, etc.) se propagent de l'élément cible vers le haut (parents, body, html, document). C'est le bouillonnement (Bubbling)."
                },
                {
                    "q": "Comment empêcher le comportement par défaut d'un formulaire ?",
                    "code": "form.addEventListener('submit', (e) => { ... })",
                    "opts": [
                        "e.stopPropagation()",
                        "e.preventDefault()",
                        "return false",
                        "e.stop()"
                    ],
                    "correct": 1,
                    "explanation": "`e.preventDefault()` empêche le rechargement de la page lors de la soumission du formulaire."
                }
            ]
        }
    ]
}